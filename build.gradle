plugins {
    id "io.freefair.lombok" version "5.3.3.3" apply false
    // spotless for license headers and linting
    id "com.diffplug.spotless" version "5.12.5" apply false
    // generation of project-wide javadocs
    id "io.freefair.aggregate-javadoc" version "5.3.3.3"

    // pom packaging for root
    id "java-platform"
}

allprojects {
    group = "com.dumbdogdiner"
    version = "3.0.3"

    // java plugin is applied in subprojects
    apply plugin: "jacoco"

    // Apply here instead of in plugins {} above to solve
    // Maven publication [..] cannot include multiple components
    // Solution: "I solved it. I put a publishing configuration into subprojects section, but applied plugin to a root project."
    // Solution source: https://discuss.gradle.org/t/problem-with-publishing-with-maven-publish-in-a-multi-module-project/1695/2
    apply plugin: "maven-publish"
    
    // Use JaCoCo 0.8.6 for (experimental) support for Java 15 class files.
    jacoco { toolVersion = "0.8.6" }

    // Define Maven Central here so that jacoco can deps resolve properly
    repositories { mavenCentral() }

    publishing {
        repositories {
            // Main publishing repo
            maven {
                name = "GitHubPackages"
                url = uri("https://maven.pkg.github.com/DumbDogDiner/StickyAPI")
                credentials {
                    username = project.findProperty("gpr.user") ?: System.getenv("GITHUB_ACTOR")
                    password = project.findProperty("gpr.key") ?: System.getenv("GITHUB_TOKEN")
                }
            }
            // Local testing maven repo
            maven {
                name = "Testing"
                url = "${rootProject.projectDir}/build/testing-mvn-repo"
            }
        }
    }

    tasks.withType(Javadoc) {
        /*
          Javadoc Fixes, part 3
          Since JDK13 the javadoc html validator was changed, making it impossible to have javadocs
          that are valid on both pre-13 and post-13 java versions.
          The original workaround was suggested here: https://bugs.openjdk.java.net/browse/JDK-8223552
          However, this workaround does not work for us since we are using aggregate-javadoc.
          So, we are using a workaround for the workaround from:
            original: https://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html
            archived: https://web.archive.org/web/20210117193942/https://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html
          which, in turn, references this: https://github.com/GPars/GPars/blob/7cddf7cf2fec1fd66ef800edccfc03315d078a2b/build.gradle#L209
        */
        options.addBooleanOption("Xdoclint:-html", JavaVersion.current().isJava11Compatible())

        // Enable frames support if running on java 11
        options.addBooleanOption("-frames", JavaVersion.current().isJava11())

        // Include private and protected in the javadocs
        options.memberLevel = JavadocMemberLevel.PRIVATE
    }

    // -------------------------
    // Check for unresolvable packages (works on root and subprojects)
    // -------------------------
    // Define unresolvable packages here
    def unresolvablePackages = ["serverversion"]
    // Define the default configuration to check (in this case ones from the "java" plugin used in our subprojects)
    // 3.X.X: Add "api" check for compile-time transistive deps (eg bukkit -> common when depending on bukkit only)
    // See: https://docs.gradle.org/6.8.3/userguide/java_library_plugin.html#sec:java_library_configurations_graph
    def configurationsToCheck = ["runtimeClasspath", "api"]
    // Define the task itself
    task checkForUnresolvablePackages {
        // Set metadata
        description = "Check that no unresolvable packages are in the given configuration"
        group = "verification"
        doLast {
            println("Checking project '$project.name' for unresolvable packages...")
            // Root project: "runtimeClasspath" not available, use "classpath" configuration instead
            if (project.name == rootProject.name) configurationsToCheck = ["classpath"]
            // Iterate through each specified configuration
            configurationsToCheck.each { config ->
                println("\nUsing configuration '$config'")
                // Iterate through each dependency in the given configuration
                configurations[config].allDependencies.each {
                    println("[debug] Checking '$it.group:$it.name:$it.version'")
                    // Check if it's in our list AND has the same group as the root project
                    // (To make sure it's actually from this codebase)
                    if (unresolvablePackages.contains(it.name) && it.group == rootProject.group) {
                        // Print to console, and also call ant.fail to fail the entire build.
                        def errMsg = "Found unresolvable dependency '$it.group:$it.name' in project '$project.name'!"
                        println(errMsg)
                        ant.fail(errMsg)
                    }
                }
            }
            // Otherwise, the check passed!
            println("Unresolvable packages check for project '$project.name' completed successfully!")
        }
    }
    
    // Finalize the build task with this task on every project.
    build.finalizedBy checkForUnresolvablePackages
    // -------------------------

    // Set pom metadata for every publication
    publishing.publications.withType(MavenPublication) {
        pom {
            // Set scm metadata (in the hope that dependabot will pick it up!)
            // See: https://github.com/dependabot/dependabot-core/blob/8c63c95770ecc84ac9597df6d53754b5d41638f9/gradle/lib/dependabot/gradle/metadata_finder.rb#L51
            scm {
                connection = "scm:git:https://github.com/DumbDogDiner/StickyAPI.git"
                developerConnection = "scm:git:https://github.com/DumbDogDiner/StickyAPI.git"
                url = "https://github.com/DumbDogDiner/StickyAPI"
            }
            // Also set issue & ci management metadata
            issueManagement {
                system = "GitHub Issues"
                url = "https://github.com/DumbDogDiner/StickyAPI/issues"
            }
            ciManagement {
                system = "GitHub Actions"
                url = "https://github.com/DumbDogDiner/StickyAPI/actions"
            }
        }
    }
}

subprojects {
    apply plugin: "io.freefair.lombok"
    apply plugin: "com.diffplug.spotless"
    
    // apply the java plugin here since root uses java-platform
    apply plugin: "java"

    // for "api" in dependencies { }
    apply plugin: "java-library"

    // Use 1.18.20+ for Java 16 compatability
    lombok { version = "1.18.20" }

    // Spotless Options
    spotless {
        encoding 'UTF-8' // all formats will be interpreted as UTF-8
        java {
            licenseHeaderFile(project.rootProject.file("LICENSE_HEADER"))
        }
    }

    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation" << "-XDignore.symbol.file"
    }

    configurations {
        jaxDoclet
        // give test dependencies access to compileOnly dependencies to emulate providedCompile
        testImplementation.extendsFrom compileOnly

        dddResource // custom configuration for our ivy resources (eg. font info)
        dddResource.description = "Resources (eg. yml or json data) to be included in jar builds"
    }

    repositories {
        // Maven Central is defined in allprojects (for JaCoCo)
        maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
        maven { url "https://papermc.io/repo/repository/maven-public/" }

        // Note: Subprojects can't have repo overrides to we have to put it here
        // Define a Ivy repo for the font width data (that way we don't need another plugin!)
        def dddResources = ivy {
           url "https://dumbdogdiner.github.io/"
            patternLayout { artifact "/[module]/[revision]/[classifier].[ext]"}
            metadataSources { artifact() } 
        }
        // Only use the Ivy repo for font width data - speeds up dependency resolution
        exclusiveContent {
            forRepositories(dddResources)
            filter { includeGroup("dumbdogdiner") }
        }
    }

    dependencies {
        implementation "org.jetbrains:annotations:21.0.1"
        implementation "io.github.classgraph:classgraph:4.8.105"
        implementation "com.github.seancfoley:ipaddress:5.3.3"

        // Tests - JUnit 5
        testImplementation "org.junit.jupiter:junit-jupiter-params:5.7.2"
        testImplementation "org.junit.jupiter:junit-jupiter-api:5.7.2"
        testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:5.7.2"

        // Tests - Mocking Suite (eg. mocking Bukkit for tests)
        testImplementation "org.mockito:mockito-core:3.11.2"
    }

    test {
	    useJUnitPlatform()
	    testLogging {
		    events "passed", "skipped", "failed"
            // Show System.out for code ran by tests
            showStandardStreams = true
	    }
        finalizedBy jacocoTestReport // report is always generated after tests run
    }

    jacocoTestReport {
        dependsOn test // tests are required to run before generating the report
        reports {
            xml.enabled true
            html.enabled true
        }
    }

    task sources(type: Jar, dependsOn: classes) {
        archiveClassifier.set("sources")
        from sourceSets.main.allSource
    }


    // Javadoc Fixes
    // Some environments (such as the builder image) do not use UTF-8 as the default encoding!
    // This sets UTF-8 as the encoding for the following tasks: delombok, compileJava, compileTestJava and javadoc.
    delombok.encoding = "UTF-8"
    compileJava.options.encoding = "UTF-8"
    compileTestJava.options.encoding = "UTF-8"
    javadoc.options.encoding = "UTF-8"

    // Javadoc: Add rootproject name in title for consistency
    javadoc.title = "$rootProject.name-$project.name $project.version API"

    // Run the linter before compiling the source code. 
    tasks.compileJava.dependsOn spotlessApply
    tasks.build.dependsOn sources

    // Per-module publishing (eg. stickyapi-common)
    if (project.name != "serverversion") { // Ignore :common:serverversion (already included in :common)
        publishing {
            publications {
                gprSubprojects(MavenPublication) {
                    artifactId "${rootProject.name}-${project.name}"
                    println("[debug] ${project.name} found component: " + components.java)

                    from(components.java)
                    artifact sources // Publish the output of the sources task
                }
            }
        }
    }
}

// Root build: include dependencies (see below)
javaPlatform.allowDependencies()

// Root build: Add api dependency to all projects we wanna include
dependencies {
    project.subprojects.each {
        if (it.name != "serverversion") api (it) {
            exclude group: "com.dumbdogdiner", module: "serverversion"
        }
    }
}

// Root build: create uber sources from subproject sources
task rootSources(type: Jar, dependsOn: subprojects.classes) {
    // Gradle 7 implicit dependency fix: depend on special common tasks
    dependsOn(":common:copyMCFontExtractor")
    dependsOn(":common:commonSources")

    archiveClassifier.set("sources")
    // Use source code from all subprojects for sources.
    // TODO: Use certain subprojects only to allow for multiple jar outputs
    from subprojects.sourceSets.main.allSource
}

// Generate a combined test report for passing/failing tests project-wide
// src: https://stackoverflow.com/a/16921750
task rootTestReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/allTests")
    // Include the results from the `test` task in all subprojects
    reportOn subprojects*.test
}

// Create a libs/modules folder with submodule jars
task copySubprojectJars(type: Copy, dependsOn: subprojects.jar) {
    // Gradle 7 implicit dependency fix: depend on special common tasks
    dependsOn(":common:copyMCFontExtractor")
    dependsOn(":common:commonSources")

    // Copy subproject jar and sources
    from(subprojects.jar) 
    from(subprojects.sources)
    into rootProject.file("build/libs/modules")
}

// Generate an additional jacoco report project-wide
// src: https://github.com/gradle/gradle/issues/10708#issuecomment-566279825
task rootJacocoMergedReport(type: JacocoReport) {
  // Gradle 7 implicit dependency fixes
  // -------------------------
  dependsOn(subprojects.test)
  dependsOn(subprojects.javadoc)

  dependsOn(subprojects.delombok)
  dependsOn(subprojects.jacocoTestReport)

  dependsOn(aggregateJavadoc)
  dependsOn(copySubprojectJars)
  dependsOn(rootTestReport)
  // -------------------------

  additionalSourceDirs.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
  sourceDirectories.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
  classDirectories.setFrom files(subprojects.sourceSets.main.output)
  executionData.setFrom project.fileTree(dir: ".", include: "**/build/jacoco/test.exec")
  reports {
    xml.enabled true
    html.enabled true
  }
}

// Root build: run copySubprojectJars after build
tasks.build.finalizedBy copySubprojectJars

// Root build: run rootSources during build
tasks.build.dependsOn rootSources

// Root build: generate project wide test, coverage and javadoc results
tasks.build.finalizedBy rootTestReport, rootJacocoMergedReport, aggregateJavadoc

// Subproject Javadoc: Finalize :javadoc meta-task with :aggregateJavadoc
task javadoc { finalizedBy aggregateJavadoc }

// Javadoc fixes (pt. 2, see above entries)
aggregateJavadoc.options.encoding = "UTF-8"

// Root Javadoc: Set title and output dir
aggregateJavadoc.title = "StickyAPI $project.version API (Aggregated)"
aggregateJavadoc.destinationDir = file("$buildDir/docs/javadoc")

task browseJavadoc {
    dependsOn aggregateJavadoc
    description "Browse javadoc"
    group = "documentation"
    doLast {
        java.awt.Desktop.desktop.browse new URI(("file:///" << System.getProperty("user.dir").replace('\\','/') << "/build/docs/javadoc/index.html").toString())
    }
}

tasks.publish.dependsOn build

publishing {
    // Uber-jar publication
    publications {
        gprRoot(MavenPublication) {
            from(components.javaPlatform)
            artifact rootSources // Publish the output of the (root) sources task
        }
    }
}
